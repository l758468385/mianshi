## HTTP缓存

前端项目中请求数据是很常见的事情，如果相同的数据重复请求多次，会造成用户流量的浪费和服务器的压力增大

缓存的原理就是在首次请求之后保存一份资源的副本，当用户再次发起相同的请求后，如果判断命中缓存则拦截请求，将之前保存的符文返回给用户，避免重新向服务器请求数据

### 一.强制缓存

HTTP 1.0有一种 **Expires**响应头，设置一个GMT （格林尼治时间），为他的过期时间，他会和本地时间比对，如果没有超过设置的过期时间，就不会向服务器发送资源请求，但是这个策略严重依赖本地客户端的时间不太好

为了解决Expired判断的局限性，从HTTP 1.1新增一个 **cache-control**  字段头来对expires功能进行扩展和完善 

**cache-control**  既可以强制缓存也可以协商缓存

比如

```javascript
res.writeHead(200,{
    'Cache-Control':'max-age = 60' // 绝对时间，滑动时间，单位是秒
})
```

**cache-control** 可以设置其他属性，比如**no-cache和no-store**  

设置no-cache是协商缓存，no-store是不进行缓存

## 二.协商缓存

顾名思义，协商缓存就是在使用本地缓存之前，需要向服务器端发起一次GET请求，与之前协商的本低缓存是否过期

比如



```javascript
//响应头设置
res.setHeader('Cache-control','no-cache') //cache-control 要先设置成协商缓存
res.setHeader('last-modified','上次修改的时间')
```

之后的请求头会携带一个字段

```http
If-Modified-Since:Fri, 30 Apr 2021 03:55:22 GMT //上次请求返回的修改时间
```

服务器就会判断这次请求携带过来的修改时间和上次传过去的修改时间是否一致，是的话则命中缓存，则不请求新资源，返回**304**响应码

#### last-modified也有问题

- 有的时候文件内容并没有发生变化，或者说文件修改的速度修改的很快，在几毫秒内修改，那么就会识别不准是否有修改过

#### ETag的协商缓存

为了弥补时间戳判断的不足，HTTP 1.1新增了一个字段头

服务器为文件进行哈希运算生存一个字符串，类似文件的指纹的独立标识，只要文件发生变化，就会造成ETag的变化

服务器设置字段头

```javascript
res.setHeader('Cache-Control','no-cache');
res.setHeader('etag','为资源文件生成的Etag字符串')
```

下一次的请求头中就会携带一个字段

```http
If-None-Match:'刚才带过来的Etag字符串'
```

服务器会进行判断，命中缓存就不请求新资源，返回304 响应码

Etag也有不要的地方，就是为了生成etag要耗费额外的服务器计算资源，影响服务器性能

