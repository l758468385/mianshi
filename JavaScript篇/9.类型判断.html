<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>类型判断</title>
  </head>
  <body>
    <script>
      // typeof 首先来说吧
      /*
          JS有八种内置类型：
            -null,undefined,boolean,number,string,object,symbol,Bigint
            除了object（引用类型），其他都叫基本类型
        */
      console.log(typeof null); //object
      console.log(typeof undefined); //undefined
      console.log(typeof false); //boolean
      console.log(typeof 1); //number
      console.log(typeof "1"); //string
      console.log(typeof {}); //object
      console.log(typeof []); //object
      console.log(typeof new Date()); //object
      console.log(typeof Symbol()); //Symbol
      console.log(typeof 123n); //Bigint
      /* 打印出来的是带字符串 懒得写注意下 */
      /* typeof是一个操作符不是函数 */

      //问题：typeof null 为什么是 'object'呢？

      // 还有一种情况要注意👇
      function foo() {}
      console.log(typeof foo); //'function'
      /*
          这样看来，function也是js的内置类型啊！但是查阅规范就可以知道，
          它实际上是object的一个 '子类型'。具体来说，函数是 '可调用对象'，
          它有一个内部属性[[call]],该属性可以使其被调用。typeof可以用来
          区分 函数和其他对象
        */

      /* 但是typeof不能判断对象具体是那种类型。所有typeof返回值为 'object'的对象
           （如数组，正则等）都包含一个[[class]]的内部属性（我们可以把它看作一个内部
           的分类）。这个属性无法直接访问，一般通过Object.prototype.toString(...)查看
        */
      console.log(Object.prototype.toString.call(new Date())); //'[object Date]'
      console.log(Object.prototype.toString.call(/reg/gi)); //'[object RegExp]'
      console.log(Object.prototype.toString.call([])); //'[object Array]'

      /* 
        instanceof的内部机制是：检测构造函数的prototype属性是否出现在某个实例对象原型链上

        通俗讲就是instanceof用来比较一个对象是否为某一个构造函数的实例

      */
    </script>
  </body>
</html>
